# ----------------------------------------------------
# 1. Instalação e Carregamento de Pacotes Necessários
# ----------------------------------------------------

# Verifica e instala pacotes que ainda não estão instalados
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("lubridate")) install.packages("lubridate")
if (!require("forecast")) install.packages("forecast")
if (!require("factoextra")) install.packages("factoextra")
if (!require("cluster")) install.packages("cluster")
if (!require("readr")) install.packages("readr")
if (!require("e1071")) install.packages("e1071")
if (!require("caret")) install.packages("caret")
if (!require("reshape2")) install.packages("reshape2")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("randomForest")) install.packages("randomForest")
if (!require("corrplot")) install.packages("corrplot")

# Carrega todos os pacotes para o ambiente de trabalho
library(tidyverse)
library(lubridate)
library(forecast)
library(factoextra)
library(cluster)
library(readr)
library(e1071)
library(caret)
library(reshape2)
library(ggplot2)
library(randomForest)
library(corrplot)

# ----------------------------------------------------
# 2. Carregamento e Preparação dos Dados
# ----------------------------------------------------

print("Iniciando o carregamento e a preparação dos dados...")

# Carregamento do arquivo CSV usando o caminho COMPLETO.
# **ATENÇÃO: VERIFIQUE se o caminho está correto para o seu ambiente.**
dados_aquicultura <- read_delim("C:/Users/mtank/Downloads/Nova pasta (9)/Aquicultura.csv",
                                delim = ";",
                                locale = locale(decimal_mark = ",", grouping_mark = "."),
                                col_types = cols(
                                  `Nomes das Regiões` = col_factor(),
                                  Ano = col_integer(),
                                  Espécie = col_factor(),
                                  `Produção (kg)` = col_number(),
                                  `Reais (R$)` = col_number()
                                ))

# Limpeza e preparação inicial dos dados
dados_limpos <- dados_aquicultura %>%
  rename(Regiao = `Nomes das Regiões`,
         Producao_kg = `Produção (kg)`,
         Reais_RS = `Reais (R$)`) %>%
  # Limpeza dos caracteres separadores de milhar, se ainda existirem
  mutate(Producao_kg = as.numeric(gsub("\\.", "", Producao_kg)),
         Reais_RS = as.numeric(gsub("\\.", "", Reais_RS))) %>%
  filter(!is.na(Regiao) & !is.na(Espécie) & !is.na(Ano)) %>%
  filter(Producao_kg > 0)

print("Dados carregados e limpos com sucesso.")

# ----------------------------------------------------
# 3. Análise Exploratória e Visualização
# ----------------------------------------------------

print("Gerando gráficos de análise exploratória...")

# Gráfico 1: Produção total por região e ano
producao_por_regiao <- dados_limpos %>%
  group_by(Regiao, Ano) %>%
  summarise(Producao_Total = sum(Producao_kg, na.rm = TRUE), .groups = 'drop')

print(
  ggplot(producao_por_regiao, aes(x = as.factor(Ano), y = Producao_Total, fill = Regiao)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Produção Total por Região ao Longo dos Anos",
         x = "Ano",
         y = "Produção (kg)",
         fill = "Região") +
    theme_minimal() +
    scale_y_continuous(labels = scales::number_format(big.mark = ".", decimal.mark = ",", accuracy = 1))
)

# Gráfico 2: Produção total por espécie
producao_por_especie <- dados_limpos %>%
  group_by(Espécie) %>%
  summarise(Producao_Total = sum(Producao_kg, na.rm = TRUE)) %>%
  arrange(desc(Producao_Total))

print(
  ggplot(producao_por_especie, aes(x = reorder(Espécie, Producao_Total), y = Producao_Total)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +
    labs(title = "Produção Total por Espécie (Todas as Espécies)",
         x = "Espécie",
         y = "Produção Total (kg)") +
    theme_minimal() +
    scale_y_continuous(labels = scales::number_format(big.mark = ".", decimal.mark = ",", accuracy = 1))
)

# Gráfico 3: Série temporal da produção total anual
producao_anual <- dados_limpos %>%
  group_by(Ano) %>%
  summarise(Producao_Total = sum(Producao_kg, na.rm = TRUE)) %>%
  ungroup()
ts_producao <- ts(producao_anual$Producao_Total, start = min(producao_anual$Ano))
plot(ts_producao, main = "Produção Total Anual da Aquicultura Brasileira", xlab = "Ano", ylab = "Produção (kg)")

# ----------------------------------------------------
# 4. Análise Multivariada (PCA e Clusterização)
# ----------------------------------------------------

print("Iniciando a Análise de Componentes Principais (PCA) - Apenas Produção...")

# Preparação dos dados para PCA (Apenas Producao_Media)
pca_data <- dados_limpos %>%
  group_by(Regiao, Espécie) %>%
  summarise(Producao_Media = mean(Producao_kg, na.rm = TRUE), .groups = 'drop') %>%
  pivot_wider(names_from = Espécie, values_from = Producao_Media) %>%
  column_to_rownames("Regiao") %>%
  select(where(~!any(is.na(.)))) # Remove colunas com NA

# Remove colunas com variância muito baixa
nzv_pca <- nearZeroVar(pca_data)
if (length(nzv_pca) > 0) {
  pca_data_filtered <- pca_data[, -nzv_pca]
} else {
  pca_data_filtered <- pca_data
}

# Executa PCA
pca_res <- prcomp(pca_data_filtered, scale. = TRUE)

print("Visualizando a relação entre regiões e a contribuição das espécies.")

# 1. Gráfico das Regiões (Similaridade de Perfis)
print(
  fviz_pca_ind(pca_res,
               geom.ind = "point",
               col.ind = "cos2", # Cor pela qualidade da representação
               gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
               repel = TRUE) +
    labs(title = "PCA - Associações entre Regiões (Similaridade de Perfis de Produção)")
) 

# 2. Gráfico das Variáveis (Contribuição das Espécies)
print(
  fviz_pca_var(pca_res,
               col.var = "contrib", # Cor pela contribuição para os componentes
               gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
               repel = TRUE) +
    labs(title = "PCA - Contribuição das Espécies (Produção Média) para a Variabilidade")
) 

print("PCA concluída.")

print("Realizando a Clusterização com o método PAM - Apenas Produção...")

# Padronização dos dados para clusterização
df_scaled <- scale(pca_data_filtered)

# Determinação do número ideal de clusters
max_clusters <- nrow(df_scaled) - 1
k <- 3 # Número de clusters mantido

if(max_clusters > 1) {
  # Gráfico do Método do Cotovelo (Elbow Method)
  cotovelo_plot <- fviz_nbclust(df_scaled, pam, method = "wss", k.max = max_clusters) +
    labs(subtitle = "Método do Cotovelo (PAM)")
  print(cotovelo_plot)
  
  # Análise da Silhueta
  silhueta_plot <- fviz_nbclust(df_scaled, pam, method = "silhouette", k.max = max_clusters) +
    labs(subtitle = "Análise da Silhueta (PAM)")
  print(silhueta_plot)
  
  # Aplicação da clusterização com k = 3
  set.seed(123)
  pam_res <- pam(df_scaled, k = k)
  
  # Visualização dos clusters
  print(
    fviz_cluster(pam_res, data = df_scaled,
                 ellipse.type = "convex",
                 palette = "jco",
                 ggtheme = theme_minimal()) +
      labs(title = paste("Clusterização PAM (k =", k, ")"))
  )
  
  # Tabela com as regiões e seus respectivos clusters
  tabela_clusters <- data.frame(
    Regiao = rownames(df_scaled),
    Cluster = pam_res$clustering
  )
  print("Distribuição das Regiões por Cluster:")
  print(tabela_clusters)
  
  # Centro de cluster (características de cada grupo)
  print("Características dos Clusters (Centroides - dados padronizados):")
  print(data.frame(pam_res$medoids))
  
} else {
  print("A clusterização não pode ser realizada. Existem poucas regiões para formar grupos.")
}

print("Clusterização concluída.")

# Geração dos gráficos de Top 5 Espécies por Cluster
dados_clusters_combinados <- dados_limpos %>%
  inner_join(tabela_clusters, by = c("Regiao" = "Regiao")) %>%
  group_by(Cluster, Espécie) %>%
  summarise(Producao_Total = sum(Producao_kg, na.rm = TRUE), .groups = 'drop')

clusters_unicos <- unique(dados_clusters_combinados$Cluster)
for(cl in clusters_unicos) {
  dados_cluster_filtrados <- dados_clusters_combinados %>%
    filter(Cluster == cl) %>%
    arrange(desc(Producao_Total)) %>%
    slice_head(n = 5) # Top 5 espécies por cluster
  
  p <- ggplot(dados_cluster_filtrados, aes(x = reorder(Espécie, Producao_Total), y = Producao_Total)) +
    geom_bar(stat = "identity", fill = "darkgreen") +
    coord_flip() +
    labs(title = paste("Produção das Top 5 Espécies no Cluster", cl),
         subtitle = paste("Regiões no Cluster:", paste(tabela_clusters$Regiao[tabela_clusters$Cluster == cl], collapse = ", ")),
         x = "Espécie",
         y = "Produção Total (kg)") +
    theme_minimal() +
    scale_y_continuous(labels = scales::number_format(big.mark = ".", decimal.mark = ",", accuracy = 1))
  print(p)
}


# ----------------------------------------------------
# 5. Modelagem Preditiva e Comparação de Modelos (Produção Total)
# ----------------------------------------------------

print("Iniciando a modelagem preditiva e comparação de modelos (Produção Total)...")

# Preparação dos dados para predição (Produção Total)
df_producao_total <- dados_limpos %>%
  group_by(Ano) %>%
  summarise(Producao_Total = sum(Producao_kg, na.rm = TRUE)) %>%
  ungroup() %>%
  arrange(Ano)

# Divide Treino/Teste (Treino = Anos anteriores; Teste = Último Ano)
treino <- df_producao_total %>% filter(Ano < max(df_producao_total$Ano))
teste <- df_producao_total %>% filter(Ano == max(df_producao_total$Ano))
ts_producao_treino <- ts(treino$Producao_Total, start = min(treino$Ano))
ts_producao_teste <- teste$Producao_Total # Valor real para comparação

# Inicializa o dataframe de métricas
df_metricas <- data.frame(Modelo = character(), RMSE = numeric(), MAE = numeric(), R_squared = numeric(), AIC = numeric(), stringsAsFactors = FALSE)

# --- Modelo 1: Regressão Linear (Produção Total) ---
modelo_lm_total <- lm(Producao_Total ~ Ano, data = treino)
previsao_lm_total <- predict(modelo_lm_total, newdata = teste)
residuos_lm <- previsao_lm_total - teste$Producao_Total

# Métricas LM
metricas_lm <- data.frame(
  Modelo = "Regressão Linear",
  RMSE = sqrt(mean(residuos_lm^2)),
  MAE = mean(abs(residuos_lm)),
  R_squared = summary(modelo_lm_total)$r.squared,
  AIC = AIC(modelo_lm_total)
)
df_metricas <- rbind(df_metricas, metricas_lm)

# --- Modelo 2: ARIMA (Produção Total) ---
modelo_arima_total <- auto.arima(ts_producao_treino)
previsao_arima_total <- forecast(modelo_arima_total, h = 1)
residuos_arima <- previsao_arima_total$mean - ts_producao_teste

# Métricas ARIMA
metricas_arima <- data.frame(
  Modelo = "ARIMA",
  RMSE = sqrt(mean(residuos_arima^2)),
  MAE = mean(abs(residuos_arima)),
  R_squared = NA, # R-squared não é padrão para modelos ARIMA com forecast
  AIC = modelo_arima_total$aic
)
df_metricas <- rbind(df_metricas, metricas_arima)

# --- Modelo 3: Random Forest (Produção Total) ---
train.control <- trainControl(method = "cv", number = 5) # 5-fold Cross-Validation
modelo_rf_total_cv <- train(Producao_Total ~ Ano, data = treino, method = "rf", trControl = train.control, tuneLength = 1)
previsao_rf_total <- predict(modelo_rf_total_cv, newdata = teste)
residuos_rf <- previsao_rf_total - teste$Producao_Total

# Métricas RF
metricas_rf <- data.frame(
  Modelo = "Random Forest",
  RMSE = sqrt(mean(residuos_rf^2)),
  MAE = mean(abs(residuos_rf)),
  R_squared = modelo_rf_total_cv$results$Rsquared[modelo_rf_total_cv$bestTune$mtry],
  AIC = NA # AIC não é aplicável
)
df_metricas <- rbind(df_metricas, metricas_rf)

# Impressão das Métricas e Gráfico Comparativo
print("Tabela de Métricas de Avaliação dos Modelos Preditivos (Produção Total):")
print(df_metricas)

print(
  ggplot(df_metricas, aes(x = reorder(Modelo, -MAE), y = MAE, fill = Modelo)) +
    geom_bar(stat = "identity") +
    labs(title = "Comparação da Precisão dos Modelos (MAE)",
         subtitle = "Valores mais baixos (em kg) indicam maior precisão na previsão",
         x = "Modelo",
         y = "Erro Médio Absoluto (MAE)") +
    theme_minimal() +
    coord_flip() +
    scale_y_continuous(labels = scales::number_format(big.mark = ".", decimal.mark = ",", accuracy = 1))
) 

print("Comparação dos modelos concluída.")


# ----------------------------------------------------
# 6. Previsão por Espécie - COMPARAÇÃO ENTRE 3 MODELOS (LM, ARIMA, RF) - CORRIGIDA
# ----------------------------------------------------

print("Iniciando a previsão e comparação de modelos para as espécies selecionadas...")

# Preparação para o loop
df_producao_total <- dados_limpos %>%
  group_by(Ano) %>%
  summarise(Producao_Total = sum(Producao_kg, na.rm = TRUE)) %>%
  ungroup() %>%
  arrange(Ano)
max_ano_historico <- max(df_producao_total$Ano)
anos_futuros <- data.frame(Ano = (max_ano_historico + 1):(max_ano_historico + 7))

# Identifica as 3 principais espécies
top_3_especies <- dados_limpos %>%
  group_by(Espécie) %>%
  summarise(Producao_Total = sum(Producao_kg, na.rm = TRUE)) %>%
  arrange(desc(Producao_Total)) %>%
  slice_head(n = 3) %>%
  pull(Espécie) %>%
  as.character()

# Adiciona a espécie específica solicitada
especies_para_previsao <- unique(c(top_3_especies, "Ostras, vieiras e mexilhões"))

# Loop para gerar os gráficos de previsão
for (especie in especies_para_previsao) {
  print(paste("Realizando análise de comparação para a espécie:", especie))
  
  # 1. Prepara os dados da espécie
  df_especie_ts <- dados_limpos %>%
    filter(Espécie == especie) %>%
    group_by(Ano) %>%
    summarise(Producao = sum(Producao_kg, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(Ano)
  
  if(nrow(df_especie_ts) > 1) {
    ts_especie_final <- ts(df_especie_ts$Producao, start = min(df_especie_ts$Ano))
    
    # Dataframe para armazenar todas as previsões
    df_previsoes_comparadas <- df_especie_ts %>%
      mutate(Modelo = "Histórico", Previsao = Producao) %>%
      select(Ano, Producao, Previsao, Modelo)
    
    # --- Previsão 1: Regressão Linear (LM) ---
    modelo_lm <- lm(Producao ~ Ano, data = df_especie_ts)
    previsao_lm <- predict(modelo_lm, newdata = anos_futuros)
    
    df_lm <- data.frame(
      Ano = anos_futuros$Ano,
      Producao = NA,
      Previsao = as.numeric(previsao_lm),
      Modelo = "Regressão Linear"
    )
    df_previsoes_comparadas <- rbind(df_previsoes_comparadas, df_lm)
    
    # --- Previsão 2: ARIMA ---
    modelo_arima <- auto.arima(ts_especie_final)
    previsao_arima <- forecast(modelo_arima, h = nrow(anos_futuros))
    
    df_arima <- data.frame(
      Ano = anos_futuros$Ano,
      Producao = NA,
      Previsao = as.numeric(previsao_arima$mean),
      Modelo = paste("ARIMA", paste(arimaorder(modelo_arima), collapse="")) # Corrigido aqui
    )
    df_previsoes_comparadas <- rbind(df_previsoes_comparadas, df_arima)
    
    # --- Previsão 3: Random Forest (RF) ---
    train.control <- trainControl(method = "cv", number = 3)
    df_rf_treino <- df_especie_ts
    
    modelo_rf_cv <- tryCatch({
      train(Producao ~ Ano, data = df_rf_treino, method = "rf", trControl = train.control, tuneLength = 1)
    }, error = function(e) {
      print(paste("Erro ao treinar RF para", especie, ":", e$message))
      NULL
    })
    
    if (!is.null(modelo_rf_cv)) {
      previsao_rf <- predict(modelo_rf_cv, newdata = anos_futuros)
      
      df_rf <- data.frame(
        Ano = anos_futuros$Ano,
        Producao = NA,
        Previsao = as.numeric(previsao_rf),
        Modelo = "Random Forest"
      )
      df_previsoes_comparadas <- rbind(df_previsoes_comparadas, df_rf)
    }
    
    # Gera o gráfico de previsão comparativa
    # Define cores de forma robusta, incluindo o nome dinâmico do ARIMA
    modelos_presentes <- unique(df_previsoes_comparadas$Modelo)
    cores_base <- c("Histórico" = "black", "Regressão Linear" = "#00AFBB", "Random Forest" = "#FC4E07")
    
    # Adiciona a cor para o modelo ARIMA dinâmico
    nome_arima <- modelos_presentes[grepl("ARIMA", modelos_presentes)]
    if(length(nome_arima) > 0) {
      cores_modelos <- c(cores_base, setNames("#E7B800", nome_arima)) # Cor amarela para ARIMA
    } else {
      cores_modelos <- cores_base
    }
    
    # Certifica-se de que a coluna Producao no Histórico é usada apenas para pontos
    p <- ggplot(df_previsoes_comparadas, aes(x = Ano, y = Previsao, color = Modelo)) +
      # Histórico (Linha e Pontos)
      geom_line(data = subset(df_previsoes_comparadas, Modelo == "Histórico"), aes(y = Producao), linewidth = 1.2) +
      geom_point(data = subset(df_previsoes_comparadas, Modelo == "Histórico"), aes(y = Producao), size = 3) +
      # Previsões (Linhas contínuas no futuro)
      geom_line(data = subset(df_previsoes_comparadas, Modelo != "Histórico" & !is.na(Previsao)),
                linewidth = 1, linetype = "dashed") +
      # Pontos de início de previsão
      geom_point(data = subset(df_previsoes_comparadas, Modelo != "Histórico" & Ano == min(anos_futuros$Ano) & !is.na(Previsao)),
                 size = 3, shape = 1) +
      labs(title = paste("Comparação de Previsão de Produção para", especie, "(até 2030)"),
           subtitle = "Modelos: Regressão Linear, ARIMA e Random Forest",
           x = "Ano",
           y = "Produção (kg)",
           color = "Modelo") +
      theme_minimal() +
      scale_color_manual(values = cores_modelos) +
      scale_x_continuous(breaks = seq(min(df_previsoes_comparadas$Ano), max(df_previsoes_comparadas$Ano), by = 2)) +
      scale_y_continuous(labels = scales::number_format(big.mark = ".", decimal.mark = ",", accuracy = 1))
    
    print(p) 
    
    # Imprime a tabela de previsões futuras
    print(paste("Tabela de Previsões (kg) para", especie, ":"))
    tabela_comparativa <- df_previsoes_comparadas %>%
      filter(Ano >= min(anos_futuros$Ano)) %>%
      select(Ano, Modelo, Previsao) %>%
      pivot_wider(names_from = Modelo, values_from = Previsao) %>%
      arrange(Ano)
    print(tabela_comparativa)
    
  } else {
    print(paste("Dados insuficientes para modelar a espécie:", especie))
  }
}

print("Análise de comparação de previsão por espécie concluída.")


# ----------------------------------------------------
# 7. NOVO GRÁFICO SOLICITADO: Top 5 Espécies por Região
#    (Usando o resultado da Tabela de Clusterização como base)
# ----------------------------------------------------

print("Gerando gráfico das TOP 5 Espécies mais produzidas por Região...")

# 1. Calcula a produção total por Espécie e Região
dados_top_por_regiao <- dados_limpos %>%
  group_by(Regiao, Espécie) %>%
  summarise(Producao_Total = sum(Producao_kg, na.rm = TRUE), .groups = 'drop') %>%
  arrange(Regiao, desc(Producao_Total))

# 2. Filtra o Top 5 para cada Região
top_5_por_regiao <- dados_top_por_regiao %>%
  group_by(Regiao) %>%
  slice_head(n = 5) %>%
  ungroup()

# 3. Gera o gráfico de barras facetado
print(
  ggplot(top_5_por_regiao, aes(x = reorder(Espécie, Producao_Total), y = Producao_Total, fill = Regiao)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    facet_wrap(~ Regiao, scales = "free_y") +
    labs(title = "Top 5 Espécies de Aquicultura Mais Produzidas por Região",
         x = "Espécie",
         y = "Produção Total (kg)") +
    theme_minimal() +
    theme(legend.position = "none",
          strip.text = element_text(face = "bold")) +
    scale_y_continuous(labels = scales::number_format(big.mark = ".", decimal.mark = ",", accuracy = 1))
) 

print("Gráfico de Top 5 por Região concluído.")
